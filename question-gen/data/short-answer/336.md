---
id: 336
topics: [23]
source: 19
---

# Background

A significant inversion in a sequence $a_1, \ldots, a_n$ is a pair $i < j$ such that $a_i > 2a_j$.

# Parts

## a

Describe an $O(n \log n)$ algorithm to count significant inversions using modified merge sort.

**Answer:** Use merge sort. After recursively sorting both halves, count cross-half significant inversions: for each $A[i]$ in the left half, count how many $A[\text{mid}+j]$ in the right half satisfy $A[i] > 2 \cdot A[\text{mid}+j]$. Since both halves are sorted, the pointer $j$ only moves forward (monotonicity), so counting across all $i$ takes $O(n)$. Then perform the standard merge. Recurrence: $T(n) = 2T(n/2) + O(n) = O(n \log n)$.

## b

Why must the counting step be done separately from the merge step?

**Answer:** The condition $a_i > 2a_j$ differs from the standard inversion condition $a_i > a_j$. In standard inversion counting, the comparison and merge are interleaved. Here the threshold ($2\times$) means we cannot combine counting with merging -- we need both halves sorted to exploit monotonicity of the count, but the merge rearranges elements. So we count first, then merge.
