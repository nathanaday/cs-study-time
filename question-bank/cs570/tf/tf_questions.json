{
  "topics": [
    { "id": "A001", "name": "Graph Connectivity and Graph Traversal" },
    { "id": "A002", "name": "Breadth First Search (BFS)" },
    { "id": "A003", "name": "Depth First Search (DFS)" },
    { "id": "A004", "name": "Bipartite Graphs" },
    { "id": "A005", "name": "Directed Graphs" },
    { "id": "A006", "name": "Directed Acyclic Graphs (DAGs)" },
    { "id": "A007", "name": "Topological Ordering" },
    { "id": "A008", "name": "Minimum Cost Arborescence" }
  ],
  "questions": [
    {
      "id": "A00101",
      "topic": "A001",
      "Question": "In an undirected graph $G = (V, E)$, an edge $e = {u, v}$ represents an asymmetric relationship, meaning $u$ being connected to $v$ does not imply $v$ is connected to $u$.",
      "Answer": "false",
      "Explanation": "An edge in an undirected graph represents a symmetric relationship. If $u$ is connected to $v$, then $v$ is connected to $u$. Asymmetric relationships are modeled by directed graphs, where edge $(u,v) \\neq (v,u)$."
    },
    {
      "id": "A00102",
      "topic": "A001",
      "Question": "Every $n$-node tree has exactly $n - 1$ edges.",
      "Answer": "true",
      "Explanation": "Rooting the tree at any node $r$, every non-root node has exactly one edge leading to its parent. This gives a one-to-one correspondence between edges and the $n - 1$ non-root nodes."
    },
    {
      "id": "A00103",
      "topic": "A001",
      "Question": "If an undirected graph $G$ on $n$ nodes is connected and has $n - 1$ edges, it must contain a cycle.",
      "Answer": "false",
      "Explanation": "By the characterization theorem (3.2), any two of the following imply the third: (i) $G$ is connected, (ii) $G$ has no cycle, (iii) $G$ has $n-1$ edges. Since $G$ is connected and has $n-1$ edges, the third property -- acyclicity -- follows. Such a graph is a tree."
    },
    {
      "id": "A00104",
      "topic": "A001",
      "Question": "In a graph with $n = |V|$ nodes and $m = |E|$ edges, the adjacency list representation requires $O(n^2)$ space, the same as the adjacency matrix.",
      "Answer": "false",
      "Explanation": "The adjacency list requires $O(m + n)$ space, while the adjacency matrix requires $O(n^2)$. For sparse graphs where $m \\ll n^2$, the adjacency list is significantly more space-efficient."
    },
    {
      "id": "A00105",
      "topic": "A001",
      "Question": "In an undirected graph $G = (V, E)$ with $m = |E|$ edges, the sum of the degrees of all nodes equals $2m$, i.e., $\\sum_{v \\in V} \\deg(v) = 2m$.",
      "Answer": "true",
      "Explanation": "Each edge $e = {v, w}$ contributes exactly 1 to the degree of $v$ and 1 to the degree of $w$, so it contributes 2 to the total sum of degrees across all nodes."
    },
    {
      "id": "A00106",
      "topic": "A001",
      "Question": "BFS (Breadth-First Search) uses a stack (LIFO) data structure to determine the order in which nodes are explored.",
      "Answer": "false",
      "Explanation": "BFS uses a queue (FIFO -- first-in, first-out), which causes it to explore nodes layer by layer. DFS uses a stack (LIFO -- last-in, first-out), which causes it to dive deeper before backtracking."
    },
    {
      "id": "A00107",
      "topic": "A001",
      "Question": "For any two nodes $s$ and $t$ in an undirected graph, their connected components are either identical or disjoint.",
      "Answer": "true",
      "Explanation": "If a path exists between $s$ and $t$, any node reachable from $s$ is also reachable from $t$ (via $s$), so the components are identical. If no path exists, no node can belong to both components, so they are disjoint."
    },
    {
      "id": "A00108",
      "topic": "A001",
      "Question": "Finding all connected components of an undirected graph with $n = |V|$ nodes and $m = |E|$ edges by repeatedly running BFS/DFS from unvisited nodes takes $O(m \\cdot n)$ total time.",
      "Answer": "false",
      "Explanation": "Although BFS/DFS may be invoked multiple times, each node and edge is processed at most once across all invocations. The total running time is $O(m + n)$."
    },
    {
      "id": "A00109",
      "topic": "A001",
      "Question": "A directed graph is strongly connected if for every pair of nodes $u$ and $v$, there exists a directed path from $u$ to $v$ and a directed path from $v$ to $u$.",
      "Answer": "true",
      "Explanation": "Strong connectivity requires bidirectional reachability between every pair of nodes, respecting edge directions. This is a stricter condition than undirected connectivity, where a single path suffices due to edge symmetry."
    },
    {
      "id": "A00201",
      "topic": "A002",
      "Question": "In BFS on an undirected graph $G = (V, E)$ starting from node $s$, every node in layer $L_j$ is at distance exactly $j$ from $s$, where distance is the minimum number of edges in any $s$-to-node path.",
      "Answer": "true",
      "Explanation": "This is theorem (3.3). BFS radiates outward uniformly from $s$, so the first time it reaches a node, it has taken the shortest possible route. Layer $L_0 = {s}$, layer $L_1$ contains all neighbors of $s$ (distance 1), and so on."
    },
    {
      "id": "A00202",
      "topic": "A002",
      "Question": "In a BFS tree $T$ rooted at $s$, if $(x, y)$ is an edge in the original graph $G$ with $x$ in layer $L_i$ and $y$ in layer $L_j$, then $|i - j|$ can be as large as 2.",
      "Answer": "false",
      "Explanation": "By theorem (3.4), $i$ and $j$ differ by at most 1. When BFS processes node $x$ in layer $L_i$, any undiscovered neighbor would be placed in $L_{i+1}$. So no edge in $G$ can connect nodes whose layers differ by more than 1 -- there are never shortcuts that skip layers."
    },
    {
      "id": "A00203",
      "topic": "A002",
      "Question": "BFS uses a queue (FIFO) data structure, which ensures that all nodes at distance $j$ from the source are processed before any node at distance $j + 1$.",
      "Answer": "true",
      "Explanation": "The FIFO property of a queue guarantees that nodes discovered earlier (closer layers) are processed first. Nodes in layer $L_j$ are all enqueued before nodes in $L_{j+1}$, so they are all dequeued and processed first as well."
    },
    {
      "id": "A00204",
      "topic": "A002",
      "Question": "BFS on a graph $G = (V, E)$ with $n = |V|$ nodes and $m = |E|$ edges, given in adjacency list representation, runs in $O(n^2)$ time.",
      "Answer": "false",
      "Explanation": "BFS runs in $O(m + n)$ time. The work at each node $u$ is proportional to its degree $n_u$, and $\\sum_{u \\in V} n_u = 2m$. Adding $O(n)$ for initialization gives $O(m + n)$. This is much better than $O(n^2)$ for sparse graphs where $m \\ll n^2$."
    },
    {
      "id": "A00205",
      "topic": "A002",
      "Question": "BFS can determine whether a path exists from node $s$ to node $t$ in a graph, but it does not guarantee finding the shortest such path.",
      "Answer": "false",
      "Explanation": "BFS both determines path existence and finds the shortest path. Since each layer $L_j$ contains exactly the nodes at distance $j$ from $s$ (theorem 3.3), the first time BFS discovers $t$, it has found a shortest $s$-$t$ path."
    },
    {
      "id": "A00206",
      "topic": "A002",
      "Question": "The general component-growing algorithm -- starting with $R = {s}$ and repeatedly adding a node $v \\notin R$ adjacent to some $u \\in R$ -- will produce the connected component of $s$ regardless of which valid edge $(u, v)$ is chosen at each step.",
      "Answer": "true",
      "Explanation": "By theorem (3.5), the set $R$ at termination is exactly the connected component containing $s$. The proof relies on two invariants: every node added to $R$ is reachable from $s$, and if any reachable node were missing, the algorithm would not have stopped. These hold regardless of edge selection order. BFS and DFS are both specific orderings of this general strategy."
    },
    {
      "id": "A00207",
      "topic": "A002",
      "Question": "For a connected graph $G = (V, E)$ with $n = |V|$ nodes and $m = |E|$ edges, the BFS time complexity $O(m + n)$ simplifies to $O(m)$.",
      "Answer": "true",
      "Explanation": "In any connected graph, $m \\geq n - 1$ (since a tree on $n$ nodes has $n - 1$ edges and is the sparsest connected graph). Therefore $n = O(m)$, and $O(m + n) = O(m)$."
    },
    {
      "id": "A00301",
      "topic": "A003",
      "Question": "In DFS on an undirected graph $G = (V, E)$, if $(x, y)$ is a non-tree edge (an edge in $G$ but not in the DFS tree $T$), then one of $x$ or $y$ must be an ancestor of the other in $T$.",
      "Answer": "true",
      "Explanation": "By theorem (3.7), when DFS examines a non-tree edge $(x, y)$, the other endpoint was discovered during the recursive call of the first. By (3.6), this makes the later-discovered node a descendant of the earlier one. Thus non-tree edges in DFS are always ancestor-descendant (vertical) connections."
    },
    {
      "id": "A00302",
      "topic": "A003",
      "Question": "In DFS, non-tree edges connect nodes in the same or adjacent layers, similar to how non-tree edges behave in BFS.",
      "Answer": "false",
      "Explanation": "This describes BFS, not DFS. In a BFS tree, non-tree edges connect nodes whose layers differ by at most 1 (horizontal connections). In a DFS tree, non-tree edges connect ancestors to descendants (vertical connections). This structural difference has deep algorithmic consequences."
    },
    {
      "id": "A00303",
      "topic": "A003",
      "Question": "DFS on a graph $G = (V, E)$ with $n = |V|$ nodes and $m = |E|$ edges, given in adjacency list representation, runs in $O(m + n)$ time.",
      "Answer": "true",
      "Explanation": "Each time a node $u$ with degree $n_u$ is explored, $n_u$ nodes are pushed onto the stack. Total pushes across all nodes is $\\sum_{v \\in V} n_v = 2m$. Each push and pop is $O(1)$, giving $O(m)$ for stack operations plus $O(n)$ for setup, totaling $O(m + n)$."
    },
    {
      "id": "A00304",
      "topic": "A003",
      "Question": "The iterative implementation of DFS uses a queue (FIFO) to determine the order in which nodes are processed.",
      "Answer": "false",
      "Explanation": "DFS uses a stack (LIFO -- last-in, first-out), which ensures the most recently discovered node is processed first, causing the algorithm to plunge deeper before backtracking. BFS is the algorithm that uses a queue (FIFO)."
    },
    {
      "id": "A00305",
      "topic": "A003",
      "Question": "In the iterative implementation of DFS, a node $v$ can appear on the stack multiple times -- once for each neighbor that pushes $v$ -- and this does not affect correctness.",
      "Answer": "true",
      "Explanation": "Multiple copies of $v$ may exist on the stack because each explored neighbor of $v$ pushes $v$ independently. Correctness is preserved because when a duplicate copy of $v$ is popped, the algorithm checks if $v$ is already marked Explored and simply skips it if so."
    },
    {
      "id": "A00306",
      "topic": "A003",
      "Question": "During a given recursive call $\\text{DFS}(u)$, all nodes that are marked Explored between the invocation and completion of that call are ancestors of $u$ in the DFS tree $T$.",
      "Answer": "false",
      "Explanation": "By theorem (3.6), all nodes marked Explored between the invocation and end of $\\text{DFS}(u)$ are descendants of $u$ in $T$, not ancestors. This follows from the recursive structure: anything discovered during $\\text{DFS}(u)$ is found through recursive calls that are children or further descendants of $u$."
    },
    {
      "id": "A00307",
      "topic": "A003",
      "Question": "In the iterative DFS implementation, nodes are marked as Explored the moment they are first added to the stack, just as BFS marks nodes as Discovered when first encountered.",
      "Answer": "false",
      "Explanation": "This is a subtle but important difference. In BFS, nodes are marked Discovered immediately when first seen. In iterative DFS, nodes are marked Explored only when they are popped from the stack and processed (their edges are scanned). A node may sit in the stack for a while before being explored."
    },
    {
      "id": "A00308",
      "topic": "A003",
      "Question": "DFS trees tend to be wide and shallow, with short root-to-leaf paths, reflecting the algorithm's layer-by-layer exploration.",
      "Answer": "false",
      "Explanation": "DFS trees tend to be narrow and deep, with long root-to-leaf paths, reflecting the algorithm's tendency to plunge as deep as possible before backtracking. It is BFS trees that tend to be wide and shallow due to layer-by-layer exploration."
    },
    {
      "id": "A00401",
      "topic": "A004",
      "Question": "A graph $G$ is bipartite if and only if its nodes can be colored using two colors such that every edge connects nodes of different colors.",
      "Answer": "true",
      "Explanation": "This is the definition of a bipartite graph. A graph is bipartite when we can partition its vertices into two sets $X$ and $Y$ such that every edge connects a vertex in $X$ to a vertex in $Y$. This is equivalent to a valid 2-coloring where adjacent vertices have different colors."
    },
    {
      "id": "A00402",
      "topic": "A004",
      "Question": "Every graph containing a triangle (3-cycle) cannot be bipartite.",
      "Answer": "true",
      "Explanation": "A triangle is an odd cycle of length 3. If we try to 2-color a triangle starting with one node as red, the next must be blue, and the third node is adjacent to both, so neither color works. More generally, any graph containing an odd cycle cannot be bipartite."
    },
    {
      "id": "A00403",
      "topic": "A004",
      "Question": "If a graph $G$ contains an even-length cycle, then $G$ cannot be bipartite.",
      "Answer": "false",
      "Explanation": "Even-length cycles can be 2-colored successfully. For example, a 4-cycle with nodes $1, 2, 3, 4$ can be colored: red, blue, red, blue. The alternating coloring works because when we return to node 1, it neighbors node 4 which has the opposite color. Only odd-length cycles prevent bipartiteness."
    },
    {
      "id": "A00404",
      "topic": "A004",
      "Question": "The BFS-based algorithm for testing bipartiteness assigns colors to nodes based on their layer number: even-numbered layers receive one color and odd-numbered layers receive the other color.",
      "Answer": "true",
      "Explanation": "Starting from node $s$ in layer $L_0$ (colored red), BFS discovers neighbors layer by layer. Layer $L_1$ gets blue, $L_2$ gets red, and so on. Since BFS guarantees that edges only connect nodes in the same layer or adjacent layers, this coloring scheme ensures that edges between adjacent layers have opposite-colored endpoints."
    },
    {
      "id": "A00405",
      "topic": "A004",
      "Question": "The BFS-based bipartite testing algorithm has time complexity $O(n^2)$ for a graph with $n$ nodes and $m$ edges.",
      "Answer": "false",
      "Explanation": "The algorithm runs in $O(m + n)$ time. It performs standard BFS which takes $O(m + n)$ time, then scans all edges once to verify the coloring, which takes $O(m)$ time. The total is $O(m + n)$, which is linear in the size of the graph, not quadratic."
    },
    {
      "id": "A00406",
      "topic": "A004",
      "Question": "In the BFS layer structure of a graph $G$, if there exists an edge connecting two nodes in the same layer $L_j$, then $G$ must contain an odd-length cycle.",
      "Answer": "true",
      "Explanation": "Let the edge be $(x, y)$ where both $x, y \\in L_j$. Let $z$ be their lowest common ancestor in the BFS tree at layer $L_i$ (where $i < j$). The cycle formed by the path from $z$ to $x$ (length $j-i$), edge $(x,y)$ (length $1$), and path from $y$ back to $z$ (length $j-i$) has total length $2(j-i) + 1$, which is always odd."
    },
    {
      "id": "A00407",
      "topic": "A004",
      "Question": "From the BFS property, every edge in a graph either connects two nodes in the same layer or connects nodes in adjacent layers.",
      "Answer": "true",
      "Explanation": "This is a fundamental property of BFS layering (fact 3.4 referenced in the text). BFS assigns each node to a layer based on its shortest path distance from the source. Since edges can only increase distance by at most 1, no edge can skip layers -- every edge connects nodes whose layers differ by at most 1."
    },
    {
      "id": "A00408",
      "topic": "A004",
      "Question": "A connected graph $G$ is bipartite if and only if it contains no odd-length cycles.",
      "Answer": "true",
      "Explanation": "The BFS algorithm proves both directions. If $G$ is bipartite, it cannot contain an odd cycle (statement 3.14). Conversely, if $G$ contains no odd cycles, then the BFS coloring succeeds (no intra-layer edges occur), proving $G$ is bipartite. Odd cycles are the only obstruction to bipartiteness."
    },
    {
      "id": "A00409",
      "topic": "A004",
      "Question": "If a disconnected graph has three connected components, the BFS-based bipartite test must be run three separate times, once for each component.",
      "Answer": "true",
      "Explanation": "BFS only explores nodes reachable from the starting node $s$, which means it only covers one connected component. To test if a disconnected graph is bipartite, we must run BFS from a starting node in each connected component and verify that each component is individually bipartite. The graph is bipartite only if all components are bipartite."
    },
    {
      "id": "A00410",
      "topic": "A004",
      "Question": "If a graph $G$ has a valid 2-coloring, then any edge in $G$ must connect a node in an even-numbered BFS layer to a node in an odd-numbered BFS layer.",
      "Answer": "false",
      "Explanation": "While a valid 2-coloring exists, not all edges necessarily connect even and odd layers. This statement would only be true if we're specifically using BFS from a particular starting node. However, if the graph is bipartite and BFS produces a valid coloring with no intra-layer edges, then every edge connects adjacent (even-to-odd) layers for that particular BFS tree."
    },
    {
      "id": "A00411",
      "topic": "A004",
      "Question": "The BFS-based bipartite testing algorithm can identify a specific odd cycle when the graph is not bipartite.",
      "Answer": "true",
      "Explanation": "When an intra-layer edge $(x, y)$ is found in layer $L_j$, the algorithm can construct an explicit odd cycle by finding the lowest common ancestor $z$ of $x$ and $y$ in the BFS tree, then forming the cycle: path from $z$ to $x$, edge $(x,y)$, path from $y$ to $z$. This cycle has length $2(j-i) + 1$, which is odd."
    },
    {
      "id": "A00501",
      "topic": "A005",
      "Question": "In a directed graph, BFS from a node $s$ finds all nodes that can reach $s$, not all nodes that $s$ can reach.",
      "Answer": "false",
      "Explanation": "BFS from $s$ in a directed graph finds all nodes that $s$ can reach by following edges in their forward direction. To find all nodes that can reach $s$, we must construct the reverse graph $G^{rev}$ (by flipping all edges) and run BFS from $s$ in $G^{rev}$."
    },
    {
      "id": "A00502",
      "topic": "A005",
      "Question": "The time complexity of BFS on a directed graph with $n$ nodes and $m$ edges is $O(m+n)$, the same as BFS on an undirected graph.",
      "Answer": "true",
      "Explanation": "BFS works almost identically in directed graphs, with the only difference being that edges are followed only in their forward direction. The algorithm still explores nodes layer by layer and processes each node and edge at most once, maintaining $O(m+n)$ time complexity."
    },
    {
      "id": "A00503",
      "topic": "A005",
      "Question": "A directed graph $G$ is strongly connected if and only if for every pair of nodes $u$ and $v$, there exists at least one path between them (in either direction).",
      "Answer": "false",
      "Explanation": "Strong connectivity requires paths in both directions between every pair of nodes. Specifically, for all nodes $u$ and $v$, there must be a path from $u$ to $v$ and a path from $v$ to $u$. Having a path in just one direction is insufficient."
    },
    {
      "id": "A00504",
      "topic": "A005",
      "Question": "Mutual reachability is a transitive relation: if $u$ and $v$ are mutually reachable, and $v$ and $w$ are mutually reachable, then $u$ and $w$ are mutually reachable.",
      "Answer": "true",
      "Explanation": "This is statement (3.16). To reach $w$ from $u$: follow the path from $u$ to $v$, then from $v$ to $w$. To reach $u$ from $w$: follow the path from $w$ to $v$, then from $v$ to $u$. Path concatenation guarantees mutual reachability between $u$ and $w$."
    },
    {
      "id": "A00505",
      "topic": "A005",
      "Question": "To test if a directed graph $G$ is strongly connected, it suffices to pick any node $s$, run BFS from $s$ in $G$, and verify that all nodes are reached.",
      "Answer": "false",
      "Explanation": "This only verifies that $s$ can reach all nodes, not that all nodes can reach $s$. We must run BFS from $s$ in both $G$ and $G^{rev}$. If both searches reach all $n$ nodes, then $s$ is mutually reachable with every node, which by transitivity (3.16) implies the graph is strongly connected."
    },
    {
      "id": "A00506",
      "topic": "A005",
      "Question": "For any two nodes $s$ and $t$ in a directed graph, their strong components are either identical or disjoint.",
      "Answer": "true",
      "Explanation": "This is statement (3.17). If $s$ and $t$ are mutually reachable, their strong components are identical (by transitivity, they're mutually reachable with the same set of nodes). If $s$ and $t$ are not mutually reachable, their strong components must be disjoint -- otherwise a shared node would make them mutually reachable by transitivity, a contradiction."
    },
    {
      "id": "A00507",
      "topic": "A005",
      "Question": "The strong component containing node $s$ can be computed by finding the intersection of nodes reached by BFS from $s$ in $G$ and BFS from $s$ in $G^{rev}$.",
      "Answer": "true",
      "Explanation": "BFS from $s$ in $G$ finds all nodes that $s$ can reach. BFS from $s$ in $G^{rev}$ finds all nodes that can reach $s$. The intersection is exactly the set of nodes that are mutually reachable with $s$, which is the definition of $s$'s strong component."
    },
    {
      "id": "A00601",
      "topic": "A006",
      "Question": "A directed graph with no directed cycles must be a tree or forest structure with at most $n-1$ edges for $n$ nodes.",
      "Answer": "false",
      "Explanation": "Unlike undirected graphs, DAGs can have many edges while still being acyclic. For example, a graph on nodes ${1, 2, \\ldots, n}$ with an edge $(i,j)$ whenever $i < j$ has $\\binom{n}{2} = \\frac{n(n-1)}{2}$ edges and no cycles. DAGs can be richly structured."
    },
    {
      "id": "A00701",
      "topic": "A007",
      "Question": "A topological ordering of a directed graph $G$ is an ordering of nodes $v_1, v_2, \\ldots, v_n$ such that for every edge $(v_i, v_j)$, we have $i < j$.",
      "Answer": "true",
      "Explanation": "This is the definition of topological ordering. All edges must point forward in the ordering -- from a lower-indexed node to a higher-indexed node. Visually, this means arranging nodes in a line so every edge goes left to right."
    },
    {
      "id": "A00702",
      "topic": "A007",
      "Question": "If a directed graph $G$ has a topological ordering, then $G$ must be a DAG.",
      "Answer": "true",
      "Explanation": "This is statement (3.18). If $G$ contained a cycle $C$, let $v_i$ be the lowest-indexed node on $C$ and $v_j$ be the node just before $v_i$ on the cycle. Then edge $(v_j, v_i)$ exists, but since $v_i$ is lowest-indexed on $C$, we have $j > i$. This edge points backward in the ordering, contradicting the definition of topological ordering."
    },
    {
      "id": "A00703",
      "topic": "A007",
      "Question": "Every DAG contains at least one node with no incoming edges.",
      "Answer": "true",
      "Explanation": "This is statement (3.19). Proof by contrapositive: if every node has at least one incoming edge, we can start at any node and walk backward indefinitely. After $n+1$ steps, we must revisit some node (by pigeonhole principle), forming a cycle. So if $G$ is a DAG, at least one node must have no incoming edges."
    },
    {
      "id": "A00704",
      "topic": "A007",
      "Question": "A directed graph $G$ is a DAG if and only if $G$ has a topological ordering.",
      "Answer": "true",
      "Explanation": "Statement (3.18) proves one direction: topological ordering implies DAG. Statement (3.20) proves the converse: DAG implies topological ordering (by induction: repeatedly remove a node with no incoming edges and order it next). These two statements establish equivalence."
    },
    {
      "id": "A00705",
      "topic": "A007",
      "Question": "The naive topological ordering algorithm that repeatedly finds and removes a node with no incoming edges runs in $O(n^2)$ time.",
      "Answer": "true",
      "Explanation": "Each iteration requires scanning all nodes to find one with no incoming edges, which takes $O(n)$ time. We perform $n$ iterations (one per node), giving $O(n^2)$ total time. This can be optimized to $O(m+n)$ by maintaining a count of active incoming edges for each node and a set of nodes with zero incoming edges."
    },
    {
      "id": "A00706",
      "topic": "A007",
      "Question": "The optimized topological ordering algorithm achieves $O(m+n)$ time complexity by maintaining for each node a count of its incoming edges from active nodes and a set of all nodes with zero active incoming edges.",
      "Answer": "true",
      "Explanation": "The optimization processes each edge exactly once across the entire algorithm. When a node $v$ is removed, we decrement the incoming edge count for each neighbor $w$ that $v$ pointed to. If $w$'s count reaches zero, we add it to the set of available nodes. This eliminates the need to rescan all nodes each iteration, achieving $O(m+n)$ time."
    },
    {
      "id": "A00707",
      "topic": "A007",
      "Question": "In a topological ordering of a DAG, the first node in the ordering must have no incoming edges, and the last node must have no outgoing edges.",
      "Answer": "false",
      "Explanation": "The first node must indeed have no incoming edges (otherwise something would need to come before it). However, the last node is not required to have no outgoing edges -- it simply has no nodes after it in the ordering that it points to. A DAG can have nodes with outgoing edges that appear last in a valid topological ordering."
    },
    {
      "id": "A00801",
      "topic": "A008",
      "Question": "The cheapest edge is always safe to include in a minimum cost arborescence.",
      "Answer": "false",
      "Explanation": "The cheapest edge may lead you down an expensive path that you can't get out of -- this is the tricky part when it comes to minimum cost arborescences."
    },
    {
      "id": "A00802",
      "topic": "A008",
      "Question": "A directed graph $G$ has an arborescence rooted at $r$ if and only if there is a directed path from $r$ to each node.",
      "Answer": "true",
      "Explanation": "Theorem 4.35."
    },
    {
      "id": "A00803",
      "topic": "A008",
      "Question": "In a minimum cost arborescence, we can safely delete the most expensive edge on a cycle.",
      "Answer": "false",
      "Explanation": "The optimal arborescence might actually need it."
    },
    {
      "id": "A00804",
      "topic": "A008",
      "Question": "An arborescence (a directed spanning tree rooted at some node $r$) must have exactly one edge entering each node except the root.",
      "Answer": "true",
      "Explanation": "By definition, an arborescence has exactly one incoming edge for each non-root node and zero incoming edges for the root. This structure ensures there's a unique directed path from the root to every other node."
    },
    {
      "id": "A00805",
      "topic": "A008",
      "Question": "If a directed graph has an arborescence rooted at $r$, then there must be a directed path from $r$ to every other node.",
      "Answer": "true",
      "Explanation": "This is the defining property of an arborescence. An arborescence is essentially a directed spanning tree, so the root must be able to reach all nodes via directed paths."
    },
    {
      "id": "A00806",
      "topic": "A008",
      "Question": "Kruskal's and Prim's MST algorithms for undirected graphs can be directly applied to find minimum cost arborescences in directed graphs.",
      "Answer": "false",
      "Explanation": "The directed nature breaks these simple greedy approaches. For example, the cheapest edge might enter the root (which violates the arborescence definition requiring no edges entering the root) or including it might force expensive choices later in the construction."
    },
    {
      "id": "A00807",
      "topic": "A008",
      "Question": "In the minimum cost arborescence algorithm, when we subtract $y_v$ (the minimum cost edge entering node $v$) from all edges entering $v$, this changes which arborescence is optimal.",
      "Answer": "false",
      "Explanation": "Every arborescence must have exactly one edge entering each non-root node $v$. So every arborescence's total cost changes by exactly the same amount (the sum of all $y_v$ values). This preserves the relative ordering, so the optimal arborescence remains optimal under the modified costs."
    },
    {
      "id": "A00808",
      "topic": "A008",
      "Question": "In the minimum cost arborescence algorithm, after modifying edge costs by subtracting $y_v$ from all edges entering $v$, all edges in the naive greedy set $F^*$ (formed by choosing the cheapest edge entering each node) have modified cost $0$.",
      "Answer": "true",
      "Explanation": "For each node $v$, we define $y_v$ as the minimum cost edge entering $v$, and we select that minimum-cost edge for $F^*$. After subtracting $y_v$ from that edge's cost, its modified cost becomes $c'_e = c_e - y_v = 0$."
    },
    {
      "id": "A00809",
      "topic": "A008",
      "Question": "In the minimum cost arborescence algorithm, if the naive greedy set $F^*$ contains a cycle $C$, that cycle must include the root node $r$.",
      "Answer": "false",
      "Explanation": "By definition of an arborescence, no edges can enter the root $r$. Therefore, $r$ cannot be part of any cycle formed by edges that each enter some node. Any cycle in $F^*$ must exist only among non-root nodes."
    },
    {
      "id": "A00810",
      "topic": "A008",
      "Question": "In the minimum cost arborescence algorithm, when we contract a cycle $C$ into a single supernode and recursively solve on the smaller graph, we might lose the optimal arborescence of the original graph.",
      "Answer": "false",
      "Explanation": "A key lemma proves that there always exists an optimal arborescence in the original graph $G$ that has exactly one edge entering the cycle $C$. This optimal arborescence corresponds to an arborescence in the contracted graph $G'$, so the recursive approach is guaranteed to find an optimal solution."
    },
    {
      "id": "A00811",
      "topic": "A008",
      "Question": "An arborescence (directed spanning tree) with $n$ nodes must have exactly $n-1$ edges.",
      "Answer": "true",
      "Explanation": "Like any spanning tree, an arborescence connects $n$ nodes in a tree structure. Since exactly one edge enters each of the $(n-1)$ non-root nodes and no edge enters the root, the total is $n-1$ edges."
    },
    {
      "id": "A00812",
      "topic": "A008",
      "Question": "If a directed graph contains cycles, it cannot have an arborescence.",
      "Answer": "false",
      "Explanation": "The original graph $G$ can contain many cycles. An arborescence is a carefully selected subgraph that forms a tree (with no cycles) while still spanning all nodes. We select edges to avoid cycles in the arborescence itself, even though the original graph has cycles."
    },
    {
      "id": "A00813",
      "topic": "A008",
      "Question": "In directed graphs, the most expensive edge on a cycle can always be safely deleted when finding a minimum cost arborescence.",
      "Answer": "false",
      "Explanation": "Just like we can't blindly include the cheapest edge, we also can't blindly delete expensive edges. Depending on the graph structure and where the root is located, the optimal arborescence might actually require that expensive edge to maintain connectivity from the root to all nodes."
    },
    {
      "id": "A00814",
      "topic": "A008",
      "Question": "In the minimum cost arborescence algorithm, each recursive call (where we contract a cycle into a supernode) reduces the number of nodes by at least one.",
      "Answer": "true",
      "Explanation": "When we contract a cycle, we replace at least $2$ nodes (the minimum for a cycle) with a single supernode, reducing the total node count. This guarantees the recursion terminates, with at most $n$ recursive calls for a graph with $n$ nodes."
    },
    {
      "id": "A00815",
      "topic": "A008",
      "Question": "Two different arborescences rooted at the same node $r$ in the same graph must have the same number of edges.",
      "Answer": "true",
      "Explanation": "Both arborescences are spanning trees of the same $n$ nodes with the same root $r$, so both must have exactly $n-1$ edges. They differ in which specific edges are selected, not in the total count."
    },
    {
      "id": "A00816",
      "topic": "A008",
      "Question": "In the minimum cost arborescence algorithm, for the naive greedy strategy to immediately give an optimal arborescence, the set $F^*$ (formed by choosing the cheapest edge entering each node) must contain no cycles.",
      "Answer": "true",
      "Explanation": "If $F^*$ forms a valid arborescence (no cycles, one edge entering each non-root node), then it must be optimal because we've chosen the cheapest possible edge entering each node. The algorithm only needs to recurse when $F^*$ contains a cycle."
    },
    {
      "id": "A00817",
      "topic": "A008",
      "Question": "In the minimum cost arborescence algorithm, after contracting a cycle $C$ into a supernode, every arborescence in the original graph $G$ corresponds to exactly one arborescence in the contracted graph $G'$.",
      "Answer": "false",
      "Explanation": "Only arborescences in $G$ that have exactly one edge entering the cycle $C$ correspond to arborescences in $G'$. If an arborescence in $G$ has multiple edges entering $C$, it doesn't have a valid corresponding arborescence in the contracted graph, since those multiple entry points collapse to the same supernode."
    },
    {
      "id": "A00818",
      "topic": "A008",
      "Question": "In the minimum cost arborescence algorithm, the modified cost $c'_e$ (defined as $c'_e = c_e - y_v$, where $c_e$ is the original edge cost and $y_v$ is the minimum cost of any edge entering node $v$) can be negative.",
      "Answer": "false",
      "Explanation": "Since $y_v$ is defined as the minimum cost of any edge entering $v$, and $c_e$ is the cost of some specific edge entering $v$, we must have $c_e \\geq y_v$. Therefore, the modified cost $c'_e = c_e - y_v \\geq 0$ is always non-negative."
    }
  ]
}
